# 0914



## DB

### DB

#### DB란

​	체계화된 데이터의 모임



#### DB로 얻는 장점

​	데이터 중복 최소화

​	데이터 무결성 (정확한 정보를 보장)

​	데이터 일관성

​	데이터 독립성 (물리적/논리적)

​	데이터 표준화

​	데이터 보안 유지



#### DB의 종류

​	(1) RDB

​	(2) NoSQL



### RDB

#### RDB란

​	key 와 value 의 간단한 관계(relation)를 table 형태로 정리한 DB



#### 용어 정리

​	스키마 (schema) : **명세** (DB 자료의 구조, 표현방법, 관계등을 기술 _ column 과 datatype 으로) 
django 사용 시 models.py 에 적은 것이 schema

​	테이블 (table) : 열(컬럼/필드) 과 행(레코드/값) 의 모델을 사용해 조직된 **데이터 요소들의 집합**

​	열 (column) : **고유한** 데이터 형식 (열, 컬럼, 필드)

​	행 (row) : 실제 데이터가 **저장되는 형태** (행, 로우, 레코드)

​	기본키 (primary key) : 각 행(레코드)의 고유 값
**반드시 설정**해야 하며, DB 관리 및 관계 설정 시 주요하게 활용
django 에서는 ID가 PK 역할을 함



### RDBMS

#### RDBMS란

​	Relational DataBase Management System
​	**관계형 모델을 기반으로 하는 데이터베이스 관리 시스템**

​	DB는 하나의 소프트웨어 프로그램
ex) MySQL, SQLite(서버형태가 아닌 파일 형식으로 응용 프로그램에 넣어서 사용), **PostgreSQL**, ORACLE, MS SQL
django ORM 사용 시 RDBMS 의 종류를 변경하는 것이 쉬움



### SQL

#### SQL이란

​	RDBMS(소프트웨어 프로그램)의 **데이터 관리를 위해** 설계된 **특수 목적 프로그래밍 언어**
( == 전부 공통된 것이 아님)
​	DB 스키마 생성 및 수정
​	자료의 검색 및 관리 (CRUD)
​	DB 객체 접근 조정 관리



#### SQL 분류

​	D*L Data Language

​	**DDL** Definition  구조(테이블, 스키마)를 정의하기 위한 명령어 (CREATE DROP ALTER)

​	**DML** Manipulation 데이터를 저장, 조회, 수정, 삭제 등을 하기 위한 명령어 (INSERT SELECT UPDATE DELETE)

​	**DCL** Control 사용자의 권한 제어를 위해 사용하는 명령어 (GRANT REVOKE COMMIT ROLLBACK)



#### SQL convention

​	사용자가 입력하는 key는 **소문자**로

​	고정(CREATE 등)된 건 **대문자**로

​	TABLE명은 **복수형**으로



### 테이블 생성 및 삭제

#### DB 생성하기

``` bash
# . 으로 시작하는 명령어는 sqlite 전용 커맨드

$ sqlite3 tutorial.sqlite3
sqlite> .database
sqlite> .mode csv # csv파일(comma seperated values) : 표를 표현하기 좋음
sqlite> .import hellodb.csv examples 
# examples라는 이름으로 Table 생성되고 hellodb.csv 의 데이터가 examples Table 에 import 됨
```



#### SELECT 

``` sqlite
SELECT * FROM examples;
```



#### view 변경 (optional)

``` sqlite
.headers on

.mode column
```



#### CREATE TABLE

**CREATE** TABLE

``` sqlite
CREATE TABLE classmates (
  id INTEGER PRIMARY KEY,
  name TEXT
);

.tables
.schema classmates  -- 무슨 명령어로 classmates라는 table이 생성되었는지
```

​	charfield는 VARCHAR 라는 이름으로 존재하지만 최초 table 생성 시 max값 지정해줘야 하기 때문에 VARCHAR 대신 TEXT 사용 

​	**DB최적화**는 **쿼리를 효율적으로 작성**하는 것이 더 중요



#### DROP TABLE

**DROP** TABLE

``` sqlite
DROP TABLE classmates;
```



``` sqlite
-- query문을 일일이 쓰는 것보다 sql 문서를 만들어 query문을 작성하는 것이 오타가 났을 때 고치기 쉽다

-- sql 문서를 읽어 query문을 적용하는 방식
.read 01_create_table.sql
.read 02_drop_table.sql
.read 03_INSERT.sql
```



### CRUD

#### Create

**INSERT**

```sqlite
INSERT INTO classmates (name, age)
VALUES ('홍길동', 25);

-- DB 확인하기
SELECT * FROM classmates;
SELECT rowid, * FROM classmates;

-- rowid (PRIMARY KEY 설정 없이 TABLE 생성 시 자동 생성되는 column)는 삭제 등으로 중간에 빈 값이 존재할 경우 재사용함
-- id PRIMARY KEY 는 INSERT 시 마지막값 +1 이 되기 때문에 마지막값(id=5)을 삭제후(id=4가 마지막이 됨) INSERT 하면 id=5 를 재사용함
-- AUTOINCREMENT 는 삭제된 값 재사용하지 않음
```



``` sqlite
INSERT INTO classmates (name, age, address)
VALUES
('김철수', 30, '대전'),
('이싸피', 26, '광주'),
('박삼성', 29, '구미'),
('최전자', 28, '부산');

-- 모든 열에 대한 데이터가 있다면 column을 명시하지 않아도 됨
INSERT INTO classmates
VALUES ('김철수', 30, '대전');

-- 반드시 필요한 정보인 경우 TABLE 생성 시에 NOT NULL 설정 (sqlite는 수정이 복잡하여 NOL NULL 설정 없이 생성했다면 지우고 다시 만드는 것이 나음)
```



#### READ

**SELECT**

``` sqlite
SELECT id, name FROM classmates;

SELECT id, name FROM classmates LIMIT 2 OFFSET 2; 
-- LIMIT == 이만큼만 가져와
-- OFFSET == 앞에 이만큼 띄고 가져와
-- LIMIT OFFSET은 페이지네이션에 사용될 수 있음

-- 조건
SELECT id, name, address FROM classmates WHERE address='서울';

-- 중복 없이
SELECT DISTINCT age FROM classmates; -- age 중복 없이 가져와
```



#### DELETE

**DELETE**

``` sqlite
DELETE FROM classmates WHERE id=5;
```



#### UPDATE

**UPDATE**

``` sqlite
UPDATE classmates
SET name='홍길동', address='제주도'
WHERE id=5;
```



### WHERE

**WHERE**

``` sqlite
-- users Table 생성 후 users Table에 users.csv 데이터 넣기

.mode csv
.import users.csv users

.tables

-- WHERE 사용
SELECT first_name, age FROM users 
WHERE age >= 30 LIMIT 10;
```



### Sqlite Aggregate Function

​	aggregate == 집합

``` sqlite
SELECT COUNT(*) FROM users;
SELECT AVG(age) FROM users WHERE age >= 30;
SELECT SUM(age) FROM users WHERE age >= 30;
SELECT MIN(age) FROM users WHERE age >= 30;
SELECT MAX(age) FROM users WHERE age >= 30;
SELECT first_name, MAX(balance) FROM users;

-- AVG(balance) 와 함께 first_name 을 찍는다면? first_name으로 나온 값은 의미없는 데이터일 것임
```



### LIKE

#### LIKE

​	패턴 일치를 기반으로 데이터를 조회하는 방법

``` sqlite
-- % : 문자열이 있을수도 없을 수도
-- _ : 반드시 여기에 있어야 한다

SELECT * FROM users WHERE age LIKE '2_';  -- 나이가 2로 시작하고 두 자리(뒤에 _가 붙었으므로)

SELECT phone FROM users WHERE phone LIKE '02%';  -- 번호가 02로 시작하고 뒤에 몇자리가 오든 상관없는 번호 (뒤에 %가 붙었으므로)

-- WHERE age LIKE '2__%' 2로 시작하고 최소 3자리인 값
-- WHERE phone LIKE '%_5114_%' 중간번호가 5114인 값
```



### ORDER BY

#### ORDER BY 

```sqlite
SELECT * FROM users ORDER BY age ASC LIMIT 10;

SELECT * FROM users ORDER BY age DESC, last_name ASC LIMIT 10;

SELECT first_name, last_name FROM users ORDER BY balance DESC LIMIT 10;

SELECT first_name, last_name, balance, age FROM users WHERE age LIKE '1_' ORDER BY balance DESC LIMIT 10;  -- 10대 잔고 많은 사람순

SELECT first_name, last_name, balance, age FROM users ORDER BY age ASC, balance DESC LIMIT 10;  -- 나이순으로 자르고 그 중 잔고 많은 사람순
```

​	ASC : 오름차순

​	DESC : 내림차순



### GROUP BY

#### GROUP BY

​	GROUP BY 사용 시 WHERE 절이 있는 경우 반드시 WHERE 절 뒤에 작성해야 함

```sqlite
SELECT last_name, COUNT(*) AS name_count from users
GROUP BY last_name;

SELECT last_name, AVG(balance) AS asset
FROM users
GROUP BY last_name
ORDER BY asset DESC
LIMIT 10;
```



### ALTER TABLE

#### ALTER TABLE

``` sqlite
-- 테이블 생성
CREATE TABLE articles (
  title TEXT NOT NULL,
  content TEXT NOT NULL
);

-- 데이터 추가
INSERT INTO articles
VALUES ('1번제목', '1번내용');


-- ALTER TABLE

-- 테이블 이름 변경
ALTER TABLE articles
RENAME TO news;

-- 테이블 컬럼 추가
ALTER TABLE news 
ADD COLUMN writer TEXT NOT NULL DEFAULT 'admin'; 
-- 데이터가 있는 상태에서 테이블 컬럼을 NOT NULL로 추가하고자 할 때는 DEFAULT 값을 지정해줘야 함
```



### SQL & ORM

#### SQL & ORM

```bash
$ python manage.py sqlmigrate users 0001

# --
# -- Create model User
# --
# CREATE TABLE "users_user" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "first_name" varchar(10) NOT NULL, "last_name" varchar(10) NOT NULL, "age" integer NOT NULL, "country" varchar(10) NOT NULL, "phone" varchar(15) NOT NULL, "balance" integer NOT NULL);
# COMMIT;
```



``` bash
$ python manage.py dbshell

sqlite> .tables
sqlite> .schema users_user

sqlite> .mode csv
sqlite> .import ../users.csv users_user

sqlite> .tables
```



#### django ORM lazy loading

``` bash
 $ python manage.py shell_plus --print-sql
 
 In [1]: User.objects.all()  
# user = User.objects.all() 하면 sql 실행 X, user 찍으면 그때 sql문 실행됨 : django ORM lazy loading
 
 In [1]: for user in users:
    ...: 	print(user)
```

​	ORM은 update 시 update 하지 않은 column도 set 한다



``` bash
 $ python manage.py shell_plus --print-sql
 
 In [1]: User.objects.count()
 In [2]: User.objects.filter(age=30).values('first_name')
 # 이렇게 해도 전체 다 가져온다음 first_name을 잘라내는게 아니라, first_name만 가져옴.
 
 In [3]: User.objects.filter(age__lte=30).values('first_name')
 # age__lte : age가 less than or equal
 
 In [4]: User.objects.filter(age=30, last_name='김').count()
 In [5]: User.objects.filter(age__gte=30, last_name='김').count()
 # AND 연산
 # age__gte : age가 greater than or equal
 
 In [6]: User.objects.filter(Q(age__gte=30) | Q(last_name='김')).count()
 # OR 연산
 
 In [7]:User.objects.filter(phone__startswith='02-').count()
 # 02- 로 시작하는 전화번호
 
 In [7]:User.objects.order_by('balance', '-age')[:10]
 # -age == age DESC
 # [:10] == LIMIT 10
```



### Django Aggregate

#### .aggregate()
​	(sum count)

```bash
 $ python manage.py shell_plus --print-sql
 
 In [1]: User.objects.aggregate(Avg('age'))
 # age__agv 라는 column으로 만들어짐(AS age__agv)
 
 In [2]: User.objects.filter(last_name='김').aggregate(Avg('age'))
 # 김 씨 성을 가진 사람들의 나이 평균
```



#### .annotate()  

​	(group by)

​	결과에 새로운 컬럼(주석)을 만들어냄 == 원본 table이 변하는 것이 아님

```bash
 $ python manage.py shell_plus --print-sql
 
 In [1]: User.objects.values('country')
 In [2]: User.objects.values('country').annotate(Count('country'))
 # 결과에 country__count 라는 column이 만들어짐
```

`	aggregate`는 전체 쿼리셋에 대한 값을 계산하고, `annotate`는 쿼리셋의 각 객체들에 적용된다

